    UGUI(Unity Graphical User Interface)
    分三部分：
    控件、Event、ITween
    可用于做菜单、显示角色头顶的信息等

# 注意设置，自适应分辨率问题
关于Canvas控件，Canvas Scaler组件

# 面板
**控件位置可以在面板进行快捷操作，跟Anchors同一处，要按Alt**
### 轴心点
Pivot（可以在面板进行快捷操作，跟Anchors同一处，要按Shift）
0.5 0.5就是物体正中间
轴心点的位置会影响UI旋转，大小改变的效果

### 锚点
Anchors（可以在面板进行快捷操作）
可以在屏幕大小改变时进行自适应，如一直贴着屏幕边
4个三角形对应组件4个点
锚点不分开则效果是位置的自适应
锚点分开则效果是大小的自适应

### PosX、PosY、PosZ、Right等...
是指轴心点与锚点的像素点
# API
```c#
// RectTransform
public class XXDemo:MonoBehaviour{
    private void Start(){
        // 世界坐标
        // this.transform.position //不分UI组件还是其他元素
        // this.transform.localPosition //当前轴心点相对于父UI的轴心点位置

        // 两种获取方式
        RectTransform rtf = GetComponent<RectTransform>();
        RectTransform rtf = this.transform as RectTransform;

        //就是this.transform.position
        // rtf.position

        // 在面板里看到的POS
        // rtf.anchoredPostion3D //自身轴心点相对于锚点的位置
        // 获取/设置锚点
        // rtf.anchorMin //等
        // rft.pivot //轴心点

        // 获取UI宽度(只读)
        // rtf.react.width

        // 设置UI宽度
        rtf.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal,250)
        rtf.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical,250)

        // Vector2 size = rtf.sizeDelta 矩阵变换大小相对于锚点之间的距离;当锚点不分开时，数值可以理解为UI宽高；锚点；物体大小 - 锚点间距

        // RectTransformUtility类 有关于UGUI操作的实用功能

        // 获取组件注意要引入UnityEngine.UI这个命名空间
    }
}
```

# 控件
在Hierarchy右键，选择UI：
选择控件后会主动引入canvas

设置时在Scene面板切换成2d模式更方便

## canvas
Sort Order属性：
同一画布下：下面层级盖住上面层级
不同画布下：取决于画布的Sort Order属性


Render Mode属性：
Screen Space - Overlay(UI元素将绘制在其他元素之前，且绘制过程独立于场景元素和摄像机设置，画布尺寸由屏幕大小和分辨率决定；世界坐标等同于屏幕坐标)
Screen Space - Camera(如果没有提供Render Camera，此时渲染模式还是Overlay；如果提供，Canvas会被绘制在一个于摄像机固定距离的平面上，且绘制效果受摄像机参数影响)
World Space(画布也相当于一个3d物体)


使用Screen Space - Camera时，
为了性能（因为如果把主Camera设置为渲染Camera的话，Canvas的所有子控件都会跟着移动），再单独创建一个UICamera，然后Clear Flags设置为Depth Only,他会仅显示自己看到的。UICamera设置Culling Mask只看UI，主Camera设置Culling Mask不看UI
再把想要显示的3d物体的层也改为UI


World Space：
想要把字放在物体上进行提示时用

## Image
将图片在面板将Texture Type改为Sprite，就能拖拽赋值到Image的面板中的Source Image
Image Type:
    Simple
        Preserve Aspect 保持贴图原始比例
        Set Native Size 将贴图设置为原始尺寸
    Sliced 切割
    Tiled 平铺
    Filled 填充
        Fill Amount(适合做技能冷却用)

## Text
支持写富文本语法
<b>1</b>
<i>1</i>
<color=red>123</color>
面板里Rich Text需要勾上

百度：UGUI图文混排

勾上Best Fit，可以让字体大小自适应

## button
Interactable 按钮是否失效
Transition 操作按钮时怎样变化
    Color Tint 设置激活，交互，失效颜色
    Sprite Swap 交互效果可以换成相应的自定义Sprite
    Animation 可以换成动画

## Toggle
复选框
根据Is On判断选中与否

## slider
滑动条
可以把按钮元素删了,Interactable取消，作为血条用

## panel
可以做多个panel，进行界面切换，显隐这些

# layout - Grid Layout Group组件
提供一个控制子元素布局的面板
会对子元素自动布局（ctrl+d复制元素），子元素此时不可手动调整位置，大小

```c#
GameObject go = new GameObject("给个名字");//复杂的则使用创建预制件 Instantiate
go.AddComponent<Image>();
// 创建的游戏对象，scale默认为1，false表示不使用世界坐标
go.transform.SetParent(this.transform,false);//不写false，这个子元素的scale会自动转换，从1变成别的，渲染模式Screen Space - Overlay则没这问题。。反正加上就对了，不用记太清
```

# 优化原理
界面中默认一张图片一个Draw Calls
同一张图片多次显示仍然为一个Draw Calls

尽量把多个小图片放在一张大图中，减少Draw Calls
操作(2021版的，edit - project settings - editor 找到Sprite Packer，mode改为启用)：选中多个图片，面板中packing Tag写上个字符串值（本人版本不能这样操作）

美工给一个大图
自己在Unity中切割
Sprite Mode用Multiple，然后Sprite Editor，根据需要切割Sprite


# 事件
```c#
public class EventDemo : MonoBehaviour
{
    public void Say()
    {
        print("a ha");
    }

    public void SayForInput(string name)
    {
        print(name);
    }
}

```
注册事件的4种方法：
1. 通过编辑器绑定方法

举例button组件：将脚本拖拽给元素，将元素拖拽到button的面板的On Click()列表中，再选择要执行的函数方法（这里是Say）
可以给方法加一个参数，参数类型不能是数组

举例InputField组件：会有On Value Changed、On End Edit、On Submit列表，且要执行的函数可以分为动态跟静态（要选动态，在执行SayForInput时我们才可以在输入框拿到输入的字符串）

2. AddListener
```c#
public class EventDemo : MonoBehaviour
{
    public void Say()
    {
        print("a ha");
    }

    public void SayForInput(string name)
    {
        print(name);
    }

    public void Start()
    {
        Button btn = this.transform.Find("Buttion").getComponent<Button>();
        // public delegate void UnityAction()
        btn.onClick.AddListener(Say);

        Button input = this.transform.Find("InputField").getComponent<Button>();
        // public delegate void UnityAction<T0>(T0 atg0)
        input.onEndEdit.AddListener(SayForInput);
    }
} 

```
3. 实现接口
输入类
IScrollHandler
IMoveHandler
...

XX类

EventSystem元素，负责管理分发事件，依靠这些进行检测：
Canvas的Graphic Raycaster
EventSystem的Standalone Inout Module组件,也可以添加Touch Input Module检测触摸屏事件

Canvas控件的面板都会有一个Raycast Target的复选框，勾上就会有射线去检测，去掉的话，检测不到，也就交互不了


4. 自定义框架
